#!/usr/bin/python

"""
This script will try to enforce the tips given in
http://chris.beams.io/posts/git-commit/.

Line length violations will cause the commit to fail.
* The subject should be shorter than 50 characters
* The line length of the body should be shorter than 72 characters

The script will ensure the following rules, by inserting them in the message.
* Capitalize the subject line
* Remove any punctuation from the subject line
* Seperate the subject line and the body with an empty line

In case of a failed commit the commit message will be saved in the .git folder
in order to used as a templete in the next commit.

The first paramter given to the 'commit-msg' git hook is the name
of the file in which the commit message is stored in.
"""

import sys
import re
import subprocess
import message_store
import operator
from pattern.en import Sentence, parse, mood, modality, INDICATIVE, IMPERATIVE, CONDITIONAL, SUBJUNCTIVE

# If the commit is to fail, due to an incorrect formated commit message, the information of why is stored here.
fail_reason = []

# If any fixups was done on to the message, information of what fixups are stored here.
fixups = []

commit_msg_fd = sys.argv[1]


def underline(text):
    return "\033[4m" + text + "\033[0m"

def red(text):
    return "\033[91m" + text + "\033[0m"

def blue(text):
    return "\033[96m" + text + "\033[0m"

def green(text):
    return "\033[92m" + text + "\033[0m"

def yellow(text):
    return "\033[93m" + text + "\033[0m"

def indent(text):
    return "\t" + text.replace("\n", "\n\t")

def mood_color(mood):
    if (mood == IMPERATIVE):
        return green
    elif (mood == INDICATIVE):
        return blue
    elif (mood == SUBJUNCTIVE):
        return red
    elif (mood == CONDITIONAL):
        return yellow

def continue_or_abort():
    sys.stdin = open('/dev/tty')
    answer = raw_input("Would you like to continue anyway? ")
    if answer.strip().lower().startswith('n'):
        message_store.save(original_message)
        sys.exit(1) # Aborts the commit.

def assert_subject_length(subject):
    """
    Asserts that the subject line is shorter than 50.
    """
    if (len(subject) > 50):
        fail_reason.append("* The subject line may not be longer than 50 characters.")


def assert_body_line_length(lines):
    """
    Asserts that the body lines are shorter than 72 characters.
    """
    for line in lines[1:]:
        if (len(line) > 72):
            fail_reason.append("* No line of the body may contain more than 72 characters.")
            break


def ensure_capitalization(subject):
    """
    Returns a correctly capitalized version of input subject line.
    """
    if (subject[0].islower()):
        fixups.append("* You should capitalize the subject line.")
        return subject[0].upper() + subject[1:]
    else:
        return subject


def ensure_punctuation(subject):
    """
    Returns a subject line without trailing punctuations.
    """
    while (subject[-1] == '.' or subject[-1] == '!' or subject[-1] == '?'):
        fixups.append("* Removed " + subject[-1] + " from the end of the subject line, no need for punctuations.")
        subject = subject[0:-1]

    return subject


def ensure_subject_and_body_seperate(lines):
    """
    Ensures that the subject line is seperated by a blank line.
    The subject and the body needs to be seperated in order for
    git to properly dicern them in the logs. Also i looks better.
    """
    if (not re.compile("^\s*$").match(lines[1])):
        lines.insert(1, "")
        fixups.append("* The subject line should be seperated from the body with a blank line.")

def spell_check(message):
    """
    Spell checks the commit message with `aspell`, if aspell does
    not exist on the system this will do nothing.

    If the spell check is run and nothing of intrest is found `None` is returned,
    otherwise a new list with the error hightlighted is returned.
    """

    aspell = subprocess.Popen(["which aspell"], stdout = subprocess.PIPE, stderr = subprocess.STDOUT, shell = True).communicate()[0].split("\n")[0]
    if (aspell == ""):
        print "No `aspell` found, install it to enable spell check."
        return None

    aspells = subprocess.Popen(["echo '" + message.replace("'", "'\\''") + "' | " + aspell + " list"], stdout = subprocess.PIPE, stderr = subprocess.STDOUT, shell = True).communicate()[0].split("\n")[:-1]

    spell_checks = False
    for _aspell in aspells:
        message = message.replace(_aspell, underline(_aspell))
        spell_checks = True

    if (spell_checks):
        print ""
        print "Found some questionable spellings:"
        print ""
        print indent(message)
        print ""

        continue_or_abort()


def mood_check(message):
    """
    Checks that the subject line is in an IMPERATIVE mood and
    that thare are no SUBJUNCTIVE sentences in the message.
    """
    mood_by_sentence = {}

    # The subject line might not contain any punctuation
    # But should allways be treated as a sentence.
    sub = message.split("\n", 1)[0]
    if (sub[-1] != "." or sub[-1] != "!" or sub[-1] != "?"):
        message = message.replace(sub + "\n", sub + ".\n", 1)

    # Split on punctuation and start of bullet point
    sentences = re.split("[.?!]|^\s?[-*]\s?", message)

    for sentence in sentences:
        if (re.match("^\s*$", sentence)):
            continue
        p = parse(sentence, lemmata = True)
        s = Sentence(p)
        mood_by_sentence[sentence] = mood(s)

    bad_subject_line = False
    bad_sentence = False

    if (sentences[0] in mood_by_sentence and mood_by_sentence[sentences[0]] != IMPERATIVE):
        bad_subject_line = True

    for s, m in mood_by_sentence.iteritems():
        s = re.sub("^\s+", "", s)
        message = message.replace(s, mood_color(m)(s))

        if (m == SUBJUNCTIVE):
            bad_sentence = True

    if (bad_subject_line or bad_sentence):
        print ""
        if (bad_subject_line):
            print "* The mood of the subject line should be " + mood_color(IMPERATIVE)(IMPERATIVE) + " not " + mood_color(mood_by_sentence[sentences[0]])(mood_by_sentence[sentences[0]]) + "."
        if (bad_sentence):
            print "* No sentence in the body of the message should be " + mood_color(SUBJUNCTIVE)(SUBJUNCTIVE) + "."
        print ""
        print indent(message)
        print ""

        print mood_color(IMPERATIVE)( " " + IMPERATIVE + "  (command)")
        print mood_color(INDICATIVE)( " " + INDICATIVE + "  (fact/belief)")
        print mood_color(CONDITIONAL)(" " + CONDITIONAL + " (conjecture)")
        print mood_color(SUBJUNCTIVE)(" " + SUBJUNCTIVE + " (opinion/wish)")
        print ""

        continue_or_abort()


msg_file = open(commit_msg_fd, 'r')
original_message = msg_file.read()
#original_message = re.sub("^\s+", "", original_message)
msg_file.close()

message = re.sub("^#(?:\n|.)*", "", original_message, flags = re.M)

lines = message.splitlines()

# If the commit message is empty git itself will dissmiss it.
if (not lines):
    sys.exit(0)


# If any potential spelling errors are found, ask the user to continue or not
spell_check(message)

# If any non compliant moods are detected, show the user and ask whether to continue or not.
mood_check(message)


# The subject is the first line of the commit message
lines[0] = ensure_capitalization(lines[0])
lines[0] = ensure_punctuation(lines[0])

assert_subject_length(lines[0])

# Check the body of the message
if (len(lines) > 1):
    assert_body_line_length(lines)
    ensure_subject_and_body_seperate(lines)

# Done with the checking!

# Did we fail?
if (fail_reason):
    # Save the message to be used in the next try.
    message_store.save(original_message)

    print "COMMIT ABORTED!"
    print "\n".join(fail_reason)
    print ""
    print "Please do try again, or add '--no-verify' to skip"

    sys.exit(1) # Aborts the commit
    


# Did we do any fixups to the message?
if (fixups):
    new_message = "\n".join(lines)
    msg_file = open(commit_msg_fd, 'w')
    msg_file.write(new_message)
    msg_file.close()

    print ""
    print "Did some fixups on the message for you:"
    print "\n".join(fixups)
    print ""
